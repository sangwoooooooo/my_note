1.2 메모리에 대해서
  메모리는 저장이라는 뜻이다. 컴퓨터에는 두가지 저장 개념이 있다. 오래 저장하는 것과 잠깐 저장하는 것 오래 저장하는 것은 파일이라는 형태로 디스크에 저장이 되며 디스크는 우리가 이해하는 하드디스크이다.
  저장하는 것은 명령어나 데이터의 형태로 메모리에 저장되는 것이며 프로그램을 종료했을 때 또는 컴퓨터를 껐을 때 심지어 프로그램을 종료하지 않았는데도 사라지는 경우가 있다.
  이렇게 단기적인 기억을 위해서 메모리가 존재하는 이유는 컴퓨터의 전체적인 성능을 높이기 위한 것이다.
  컴퓨터의 성능은 무엇에 좌우될까?
  처음 설명한 CPU 연산의 능력, 속도이다. 속도는 클럭으로 표현을 하였다. 빠르게 처리하는 것이 컴퓨터의 성능이다.
  메모리가 왜 컴퓨터의 전체 성능을 좌우할까?
  CPU가 일을 하려면 일의 내용이 CPU로 전달이 되어야 한다. 이 명령어나 데이터는 파일에 일부로 담겨있다. 파일은 하드디스크에 저장이 되어 있다.
  파일의 일부 내용이 하드디스크에서 CPU까지 전달하려면 데이터가 BUS를 타야한다. 컴퓨터 안에도 버스가 있다. BUS의 약어를 찾아봐도 나오지 않는거로 봐서는 우리가 타는 BUS에서 유래되었다고 생각해도 될 것 같다.
  개념적으로는 같다. 컴퓨터 안에 데이터들을 싣어 날라주는 연결선이다. 데이터 버스 이렇게 부른다.
  그러면 하드디스크에 있는 파일의 일부가 이 버스를 타고 CPU로 올라간다. CPU에서 일처리가 끝나면 결과가 다시 버스를 타고 어디론가 흘러간다. 이렇게 버스로 컴퓨터 안에서 오간다.
  이때 문제는 버스가 상대적으로 느리다는 것이다. 상대적이라는 말을 이해해야 하는 것은 컴퓨터 안에서 데이터가 오가는 속도는 굉장히 빠르다.
  사실 하드디스크가 느리다고 말하지만, 엄청난 속도로 실린더를 돌고있다. CPU가 빠른 처리를 하기 위해 하드디스크의 파일의 내용 일부를 메모리에 올려 놓고 수행을 한다.
  여기서 자꾸 프로그램의 일부라고 하는 이유는 프로그램이 얼마나 큰가 그 파일이 메모리에 한꺼번에 올라가는 것이 아니다.
  메모리는 매우 한정된 공간이기 때문에 프로그램 중 일부가 올라가는 것이다. 메모리는 CPU가 하고자 하는 일을 임시 저장한다. 
  메모리는 하드디스크보다 훨씬 속도가 빠르기 때문에 CPU의 일거라를 바로바로 줄 수가 있다. 그래서 CPU가 얼마나 빨리 처리하느냐도 중요하지만, 옆에 일을 얼마나 많이 잘 대기 시켜줄 수 있느냐도 중요하다.
  메모리는 그래서 일을 쌓아두는 임시 창고 같은 곳이다. 그래서 그 창고의 크기가 중요하다. 그래서 CPU는 속도가 중요하고 메모리는 크키가 중요하다.
  사실 메모리를 많이 쓰게 되면 속도는 빨라질 수 있다. 하지만 창고가 크다고 해서 일처리가 느리다면 메모리만 많다고 일이 빨리지는 것은 아닐 것이다. 전체 컴퓨터 성능에는 영향을 미친다.
  메모리가 많아야 하는 경우는 어떤 경우 일까?
  일처리를 빨리만 해야 한다면 사실 CPU의 성능이 중요할텐데, 메모리가 많아지면 성능이 좋아질 수 있는 경우는 많은 양의 데이터를 한꺼번에 메모리에 올려 실행하는 프로그램이 있는 경우이다.
  대표적인 것이 게임이다. 최근 게임들을 보면 용량이 엄청 크다. 그래픽 사양도 높다. 한꺼번에 메모리에 올려야할 파일도 많아진다.
  그리고 여러개의 작업을 동시에 많이 하는 경우라면 메모리가 많이 필요하다. 이유는 메모리에 여러개의 프로그램의 일부분이 올라가기 때문이다.

1.2.1 메모리 동작 원리
  기억 소자로 구성된 메모리 일반적으로 메모리라고 하면 기억이라는 개념이다. 컴퓨터에서 말하는 메모리는 기억소자 즉 반도체를 의미한다.
  반도체는 특성상 전류를 흐르게도 하고 흐르지 않게도 하는 특징이 있다. 이를 이용해서 임시적인 내용들을 기억하게 만드는 것이다.
  컴퓨터는 이진 1과0으로 값을 저장하기 때문에 기억 소자는 상태가 ON 인지 OFF인지 수준으로 기억하게 되는 것이다.
  반도체 기억장치의 기본 요소는 기억 소자(memory cell)이다. 모든 반도체 기억소자들이 갖는 공통적인 성질이 있다.
  두개의 안정된 상태를 갖는다. 1과 0이다. 상태를 세트할 수 있도록 쓰여질 수 있다. 상태를 감지할 수 있도록 얽혀질 수 있다.
  쓰는 동작인 경우는 기억 소자의 상태를 1또는 0으로 만들어 준다는 의미이고 읽기 동작이라는 것은 그 소자가 갖는 현재 상태가 어떠한 상태인지를 알아오는 개념이다.
  기억 장소라는 개념에서 확장하면 저장 장소라는 개념의 하드디스크, CD/DVD, USB저장장치와 같은 보조 기억장치까지를 의미한다.
  메모리가 이런 저장장치와의 차이는 휘발성이라는 특징이다. 시스템이 활성화 된 상태에서 그 값을 기억하고 있다가 다시 시스템의 shutdown과 함께 지워지게 된다.
  그리고 저장/읽기 속도 면에서 현저하게 차이가 난다. CPU와 가장 가까이 있는 레지스터 메모리, 캐시 메모리, 주기억 장치, 보조기억 장치는 각각 아래와 같이 그 특성이 차이가 있다.
  메모리 동작 메모리는 정보에 대해서 1또는 0으로 저장이 되는데, 이 정보를 유지하기 위해서는 전기적으로 연속으로 재충전이 되어야 한다.
  이를 리프래시라 하고 메모리 타이밍이라고 한다. 메모리는 정보를 저장(write)하거나 저장된 정보를 읽기(read) 위하여 바둑판과 같이 열(raw, 가로)과 행(column, 세로)으로 구성된
  martrix(행렬)구조의 주소(address)를 가지고 있다. 이를 두고 CAS(Column Address Strobe)와 RAS(Row Address Strobe)라 부르는데 프로세서가 메모리에 있는 정보를 읽거나 메모리에 정보를 기록할 때는
  먼저 가로줄에 신호(RAS)를 보내고 나서 세로줄에 신호(CAS)를 보내어 주소를 확인한다.
  어떤 주소에 데이터가 들어있는지 아니면 비어 있는지는 CAS가 담당하며 CAS 신호가 없어지면 그 주소에 다시 새로운 정보를 저장한다.
  메모리 동작 과정 메모리의 동작과정은 다음과 같다.
  1) CPU가 메인보드 칩셋에 데이터를 요청하면 메인보드 칩셋은 그 데이터가 있는 곳의 행(raw, 가로)주소를 메모리에 보낸다. 이것을 하는데는 각각 1사이클(Hz)가 걸린다.
  2) 행 주소가 메모리의 행 주소 버퍼로 들어오면, 센스 엠프(sense amp)가 그 행에 들어있는 모든 셀을 읽어낸다. 이렇게 행 부분을 읽는 신호는 RAS(row address strobe, 행 주소 스트로브)
      라고 부르고, 읽는데 걸리는 시간은 RAS-to-CAS delay(RAS와 CAS 사이의 지연시간)라고한다. 이 과정은 2~3사이클이 걸린다.
  3) 행 주소만으로는 필요한 데이터가 어디 있는지 알 수 없으니 이번에는 열(세로 줄) 주소를 받는다. 그러면 CAS(column address strube, 열 주소 스트로브)신호가 일어나 정확히 열을 찾아낸다.
      이때 걸리는 시간을 CAS latency(CAS 지연시간)라고 한다. 이것을 하는데도 역시 2~3 사이클이 걸린다.
  4) 정확한 행과 열을 찾았으니 필요한 데이터를 찾은 셈이다. 메모리 셀에 있는 내용이 출력 버퍼(output buffer)로 옮겨진다. 이 것을 하는데는 1사이클이 걸린다.
  5) 마지막으로 메인보드 칩셋이 출력 버퍼의 내용을 읽고 CPU로 전달한다. 이때 각각 1사이클씩 모두 2사이클이 걸린다.

  메모리 성능 메모리의 속도는 메모리가 CPU와 데이터를 주고 빋는 시간을 말한다. 이를 엑세스라 부르며 단위는 ns(nano-secode) - 10억분의 1초로써 메모리 속도의 기준이 된다.
  리프레시 시간 메모리는 일정 시간마다 재충전을 해줘야 하는데, 그렇지 않으면 정보는 사라지게 된다. 이 일정기간을 리프레시 시간이라고 한다. 이는 메모리에서 한 번 읽고 나서 다시 읽을 수 있는 사이 시간을 말한다.
  메모리 엑세스 시간 메모리 엑세스 시간은 데이터를 읽어오라는 명령을 받고 데이터를 읽기 시작하기까지의 시간을 말한다. CPU에서 명령어를 처리할 떄 명령어가 갖는 주소인 CAS, RAS 데이터를 보낸다.
  그러면 CPU에 그 주소에 해당하는 값을 가져오게 되는데 걸리는 시간이 엑세스 시간이다.
  사이클 시간 사이클 시간은 메모리 작업이 완료와 동시에 대기 신호를 내놓은 후 다음 신호를 받을 준비가 되었다는 신호를 주기까지의 시간이다.
  사이클 시간 = 메모리 엑세스 시간 + 리프레시 시간
  
  
  
