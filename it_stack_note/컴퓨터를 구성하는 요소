1.1 컴퓨터를 구성하는 요소
  컴퓨터 내부를 단순하게 들여다보면 크게 4가지 정도로 구성된다고도 말할 수 있습니다.
  CPU, 메모리, 디스크, IO
  CPU는 앞서 말했듯이 연산장치입니다. CPU는 무언가를 열심히 계산하고 있습니다. 프로그램이라는 것에 속해 있는 명령어를 열심히 수행하고 있습니다.
  명령어라는 것을 쪼개보면 다시 연산들의 연속입니다.
  그래서 CPU는 계속적으로 무언가를 동작시키고 있습니다. 컴퓨터에서 인터넷 브라우저를 켜는 순간도 어떤 명령들이 계속 실행이 되고 있는 것입니다.
  과거 DOS시절이라면 시커면 화면에 명령어를 첬을텐데, 동작이 되는 것인데, 윈도우라는 운영체제는 사용자들이 편리하도록 마우스 클릭만으로
  실행이 되도록 제공을 해주는 것입니다. 여기서 윈도우는 운영체제입니다.
  마우스를 클릭하는 순간 컴퓨터는 어떤 프로그램을  실행하는 명령을 내릴 것입니다. 그 명령어가 실행되고, 해당하는 프로그램의 명령들을 CPU는 열심히 수행합니다.
  CPU는 보통 얼마나 빠르냐로 성능을 말합니다. 얼마냐 빠르냐는 것은 1초 안에 얼마나 많은 명령어들을 처리할 수 있느냐입니다.
  CPU으 속도를 이야기할 때 헤르쯔 단위로 표현을 하는데, 4.0GHz인 헤르쯔는 진동수, 클럭수입니다.
  CPU가 떨어서 진동의 의미는 아니고, CPU가 명령을 받기 위해서는 그 명령어가 넘어가는 처리를 해줘야 하는데, 이게 클럭입니다.
  이것이 얼마나 빠르냐에 따라서 해당하는 CPU가 얼마나 빠른 속도로 명령어를 처리할 수 있냐로 말할 수 있습니다.
  무조건 클럭수만 빠르다고 CPU가 계산을 할 수 있는 것은 아닐테지만, 빠르게 넘겨줘야 빠르게 처리하니 빠른 클럭이 의미가 있습니다.
  CPU 계산처리 시간을 감안해서 클럭수는 정해져서 출시가 되어 있을 것입니다. 그런데, 간혹 오버 클럭이라는 말을 쓰는데, 이게 바로 이 클럭을 반 강제로 빠르게 하는 것입니다.
  CPU가 더 많은 일을 처리하도록 그렇다면 약간 빨라질 수도 있다고 봅니다.
  제품이라는 것은 안전하게 사용자가 사용하도록 되어 있을테니 약간 올리는 것은 가능할지도 모르지만, 너무 과하게 된다면 CPU가 과부하가 걸려서 더욱 망가질 수도 있는 것입니다.
  CPU와 바로 연결되어 있는 것은 내부적으로야 BUS이겠지만, 크게 봤을 때는 메모리입니다.
  메모리가 바로 연결이 되어 있다고 볼 수 있습니다. 메모리에는 지금 당장 실행을 해야하는 명령어가 담겨져 있습니다.
  CPU가 일을 한다면 일거리를 잠깐 저장해놓는 것입니다. 잠깐 저장한다는 말을 조금 잘 이해할 필요가 있습니다. 말 그대로 잠깐입니다.
  없어질 수도 있고, 다음 명령어가 그 자리를 차지할 수도 있습니다. 이와 디스크가 비교됩니다.
  디스크에는 파일들이 저장되어 있습니다. 파일은 사용자가 삭제하거나 디스크에 문제가 있지 않은 이상 반영구적으로 유지됩니다.


1.1.1 CPU의 구성 및 종류
  CPU 개요 컴퓨터의 핵심 CPU(Central Processing Unit)와 폰노이만 구조 컴퓨터 시스템을 이루는 3대 구성이 있다면 CPU,메모리,디스크이다.
  여기에 I/O까지 추가 된다면 그것을 컴퓨터를 이루는 기본 골격이라고 할 수 있는데, 이것을 제안한 것이 폰 노이만이다.
  주요 특징은 명령어/데이터 로드/실행/저장을 순차적으로 수행하는 것과 데이터/프로그램 메모리를 하나의 버스를 접근하는 구조이다.
  폰 노이만 구조는 중앙 처리 장치라는 것이 있고 이 중앙 처리 장치를 통해서 연산을 수행하게 되는  구조이다.
  이 CPU(중앙 처리 장치)는 각종 연산을 수행하고 기억장치에 기억되어 있는 명령어들을 수행하는 컴퓨터 시스템을 이루는 핵심 부품이다.
  CPU의 속도 헤르쯔와 Clock CPU는 수를 계산하는 칩으로 이해하면 되는데, 그 원리는 덧셈기와 같다.
  대게 컴퓨터의 성능을 CPU의 속도와 메모리의 용량으로 표현할 수 있는데, CPU의 속도의 단위가 헤르쯔(Hz)이다.
  Hz라고 하면 통신 분야에서 사용되는 주파스와 같은 의미인데, 주파수라는 것이 1초에 몇 번이나 진동하는 가라는 의미이다.
  1 헤르쯔는 1초에 한 번 왕복 운동이 반복된다는 의미이다.
  예를 들어 100Hz는 어떠한 현상이 1초에 100번으 반복 혹은 진동됐다는 의미이다.
  CPU 일정한 속도로 동작하기 위해서는 일정한 간격으로 전기적 펄스를 공급하는데, 이 전기적 신호가 초당 CPU에 공급되는 횟수라는 개념에서 Hz라는 단위를 쓴다.
  이 시스템내의 CPU에 전기적으로 공급되는 신호를 Clock이라고 하는데, 이것은 주기적으로 일정한 시그널을 보내주는 칩이다.
  Clock에서는 일정한 볼트로 주기적으로 신호를 발생한다. 그러면 CPU는 이 신호를 받고 데이터를 주거나 받고 처리하게 된다.
  이 신호 한 번에 의해서 CPU에서 한 개의 명령이 처리된다.
  이 반복적 신호가 들어올 때마다 명령어를 수행하기 때문에 빠르게 들어온다는 것은 결국 빠른 속도의 처리 능력을 갖는 시스템을 의마하는 것이다.
  CPU의 속도를 Hz로 나타내고 이 Hz가 높으면 속도가 빠른 성능의 CPU가 되는 것이다.
  CPU의 구성도 CPU의 내부 구성은 크게 산술/논리 장치(ALU), 제어 장치, 레지스터로 구성되어 있다.
  산술은 덧셈을 수행하는 것이고, 제어 장치는 시그럴을 통해서 데이터 흐름을 통제하는 것이며 레지스터는 CPU내부의 메모리이다.
  CPU의 내부 구성 산술 논리 연산장치 산술논리연산장치(ALU : Arithmetic Logic Unit)는 산술적인 연산과 논리적인 연산을 담당하는 장치로 가산기, 보수기, 누산기, 기억 레지스터, 데이터 레지스터 등으로 구성된다.
  캐시나 메모리로부터 읽어 온 데이터는 레지스터(Register)라는 CPU전용의 기억장소에 저장되며, ALU는 레지스터에 저장된 데이터를 이용하여 덧셈,곱셈 등과 같은 산술 연산을 수행한다.
  부동소숫연상장치(FPU)와 정수연산장치, 논리연상(AND, OR 등)장치 등이 있다.
  CPU의 내부 구성 요소 중 제어 장치 제어장치는 CPU가 자신 및 주변기기들을 컨트롤하는 장치로, 프로그램의 수행 순서를 제어하는 프로그램 계수기(program counter),
  현재 수행중인 명령어의 내용을 임시 기억하는 명령 레지스터(instruction register), 명령 레지스터에 수록된 명령을 해독하여 수행될 장치에 제어신호를 보내는 명령 해독기(instruction decoder)로 이루어져 있다.
  제어 장치 구현 방식은 아래와 같이 Hardwired 방식과 Micro Program 방식이 있다.
  Hardwired(고정 배선 제어) : 제어신호가 Hardwired Circuit에 의해서 생성되도록 하드웨어 구성, 상태계수기와 PLA(Procrammable Logic Array)회로로 구성, 고속 처리, 고가, RISC 시스템에 적용
  Micro Program : 발생 가능한 제어 신호들의 조합을 미리 구성하여 ROM에 저장하였다가 필요 시 신호를 발생시키는 Software 방식, 하드웨어 방시에 비해 속도 낮고 가격 저렴, CISC에 적용
  CPU의 내부 구성 레지스터 레지스터(Register)는 중앙처리장치(CPU) 내부에 있는 기억장치이다. 주로 산술 연산 논리장치에 의해 사용되는 범용 레지스터(Genaral-Purpose Register)와 PC 등 특수 목적에 사용되는
  전용 레지스터(Dedicated-Purpose Register)로 구분할 수 있다. 아래는 16bit Machine의 레지스터 구조이다.
  레지스터의 종류는 IR(Instruction Register), PC(Program Counter), AC(Accumulator)가 있다. 각각 CPU 내의 메모리로 다음과 깉이 사용된다.
  명령어 구조 명령어는 시스템이 특정 동작을 수행시키는 작은 단위이다.
  명령어는 코드로 되어 있는데, 아래와 같이 동작코드(Op-code : Operational Code)와 오퍼랜드(Operand)로 구성되어 있다.
  명령어(Instruction) = 동작 코드 + 오퍼랜드(Operand)
  동작 코드(Op-code) : 각 명령어의 실행 동작을 구분하여 표현
  오퍼랜드(Operand) : 명령어의 실행에 필요한 자료나 실제 자료의 저장 위치
  명령어 수행 과정
  (1). 읽기(Petch Instruction) : 메모리에서 명령을 가져온다.
  (2). 해석(Decode Instruction) : 명령어를 해석한다.
  (3). 실행(Excute Instruction) : 명령을 수행한다.
  (4). 기록(Write Back) : 수행한 결과를 가져온다.

  명령어를 수행하기 위해서 명령어를 가져오는데 이를 Fetch라 한다. Fetch 사이클은 아래와 같다.
  Program Counter(PC)는 Fetch할 다음의 명령어 주소를 갖고 있다.
  프로세스는 PC가 가리키는 주소위치에서 명령어를 가져오면서 PC를 증가시키고 명령문은 Instruction Register(IR)에 Load 된다.
  Load된 명령어는 수행과정이 진행되는데, 명령어를 수행하는 Exccute Cycle Fetch과정에서 가져온 명령어를 실제 ALU(가산기)에서 처리하게 된다.
  명령어 처리 방식 RISC와 CISC RISC(Reduce Instruction Set Computer)는 컴퓨터 내부적으로 사용하는 명령어 세트를 단순화 시켜서 처리하는 형태의 구조이다.
  단순한 명령을 조합해서 하나의 기능을 추가하게 된다.
  
  CISC(Complex Instruction Set Computer)는 하나의 기능에 해당하는 하나의 명령이 있는 개념이다.
  
  RISC는 프로세스가 수행하는 시간을 결정하는 변수로는 명령어의 개수, 명령어 당 평균 동작 단계의 수, 평균 시간을 곱한 것으로 계산할 수 있다.
  또한 파이프라인화 하여 명령어를 동시 수행할 수 있는 장점을 갖는다.
  실행시간 = n * s * t(n : Instruction 개수 s : Instruction당 평균 동작 단계의 수, t : 한 동장 단계의 수행시간)
  
  CISC는 복잡하고 많은 명령어를 자체적으로 포함하는 내장 방식 프로세서로써 각 명령어 마다 여러 Cycle에서 수행한다. 
  명령어 집합이 다양해짐에 따라서 프로세서 구조의 복잡도가 증가하게 된다.

  CISC와 RISC 비교
  CISC : 여러 사이클로 명령어 처리, 많은 명령어가 메모리에 참조, 복잡한 마이크로 프로그램 특성
  RISC : 하나의 사이클로 명령어 수행, 메모리 Load/Store명령만 처리, 파이프라이닝, 슈퍼스칼라 가능

  CISC는 가능한 적은 수의 명령으로 작업을 수행하는 것이 목적이다. 예를 들어 살펴보면 다음과 같다.
  MULT 5:7, 4:3 여기서 MULT라는 것이 복합 명령어(Complex Instruction)가 되는 것이다.
  고수준의 언어와 비슷하고 사용자가 봐도 의미를 이해할 수 있다. 이것을 RISC로 접근할 경우 간단한 명령어들의 조합으로 구성할 수 있다.
  "MULT"가 각각 "ROAD", "PROD", "STORE"로 분리되어 아래와 같이 처리된다.
  LOAD A, 5:7 LOAD B, 4:3 PROD A,B STORE 5:7, A
  차이점은 MULT라는 명령어를 위해서는 내부적으로 여러 사이클의 수행을 하게 되고, RISC인 경우는 한 클럭에 한 개의 명령을 수행할 수가 있다.
  이렇게 단일 형태로 실행되기 때문에 파이프 라이닝이나 슈퍼 스칼라 방식의 처리가 가능하다.

  RISC 한계를 극복하는 EPIC(Explicitly Parallel Instruction Computing) RISC 기술은 여러 개의 명령어를 실행 유니트로 동시에 실행하는 것이 핵심이다.
  프로그램 코드의 수행은 선형으로 진행되고 실행 중간 위치가 중간 조건에 따라 바뀌는 분기가 발생하는 문제가 빈번하고 이전의 실행 결과에 의해 다음 연산이 연계되어 진행되는 경우가 많다.
  RISC방시은 한계가 존재하고 기존의 병령 처리 기법에 프로세서에 의해서만 이루어지기 때문이다.
  소프트웨어에서 미리 병령처리에 적합하도록 프로그램을 만들어 준다면 병렬 처리 효율을 극대화할 수 있게 되는 명시적인 병렬처리 방식인 EPIC가 필요하다

  EPIC(Explicitly Parallel Instruction Computing)는 HP와 Intel이 공통으로 정의하고 설계한 64비트 마이크로프로세서용 명령어 셋이다.
  32Bit CISC 및 RISC 마이크로프로세서 아키텍처의 32비트 레지스터, 분기 예측, 메모리 지연, 암시적 병령 처리 등의 문제를 해결하기 위한 설계 방식으로 
  최대 128개의 일반 및 부동 소수점 단위 레지스터를 제공하고, 계산 작업을 수행하기 위하여 명시적인 병렬 처리를 제공 병령 처리 과정이 소프트웨어를 기계어로 번역하는 과정에서
  명확하게 지정된 병렬 처리 명령어를 사용한다. 즉 컴파일 시에 병렬 실행 가능한 명령어를 모아 실행 파일 생성 후
  프로그램 생성 시 병렬처리가 가능하다는 의미이다.

1.1.2 컴퓨터구조 + 운영체제
  컴퓨터 구조는 CPU, 메모리, 디스크로 나뉘어 있습니다.
  CPU ALU(Arithmetic Logic Uit) + 레지스터 기술연산, 제어
  캐시메모리 CPU와 메모리 사이에 존재하면서 명령어를 빠르게 전달하기 위한 메모리
  프로그램의 일부분이 메모리에 올라오고 이때 프로세스라고 하며 메모리에는 여러 프로세스의 일부가 올라오게 된다. 그래서 메모리는 교체에 대한 알고리즘이 필요하다.
  가상 메모리가 있다. Virtaul 메모리는 디스크에 파일로 존재한다. 메인 메모리의 단가가 비싼 관계로 많은 프로세스가 동시에 실핻될 때에 프로세스 일부가 메인 메모리로 올라갈 때
  일부는 디스크의 파일을 마치 메모리처럼 매핑해서 사용하고, 사용되어지지 않는 일부를 SWAP하는 방식으로 내렸다가 올렸다가 하면서 메모리처럼 사용하는 방식이다.
  디스크의 관리 최소 탐색 알고리즘, 실린더가 있고, 원통을 돌리면서 겹겹이 쌓인 원통의 층수와 원판의 빠르기 속도 등에 의해서 속도 결정이 얼마나 빠르게 데이터를 찾아가는가가 관건이다.
  이제 SSD로 변화되는 시기라서 중요도에 대한 비중이 떨어지지만 여전히 대용량 저장을 위해서는 개넘이 필요하다.
  디스크가 여러개 있는 것을 RAID라고 한다.
  프로그램 개발(C, C++, Java) -> 컴파일 -> 프로그램 어셈블 -> 어셈블러 -> 기계어 코드(바이너리) = 실행파일
  컴파일을 하면서 오브젝트 코드, 목적 코드라고 하는 파일로 만들어지고, 링크라는 과정을 통해서 실행 화일 또는 DLL과 같은 파일로 만들어짐.
  프로그램 -> 프로세스 -> 쓰레드
  스케쥴링 : 다중 프로그램 -> 프로세스가 되었을 때 어떤 프로세스를 선택할 때 전략 필요 선점형(Preeptive)
  문맥이 교체 되는 것을 문맥교환(Context Switching)이라고 하고, 이 현상이 빈번하게 일어나느 것을 스레싱이라고 합니다.
  그래서 아주 많은 프로그램을 동시에 띄우면 컴퓨터가 갑자기 느려지는 이유가 이 쓰레싱 현상때문입니다.
  



  



https://wikidocs.net/22295
